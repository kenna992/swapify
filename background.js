const e="fb-group-scan",t=120;let s=!1,r=null;const n=18e5;let a=new Set,o=null;let i=!1;async function c(e,t=null){s=e,r=t;try{await chrome.storage.sync.set({scanState:{isRunning:e,startTime:t}}),void 0!==j&&await j.persistOnCriticalEvent("scanStateChange")}catch(n){}}let u=!1,l=0;let h=null,d=0;const m="fb_keyword_monitor",g=2;let p=0,y=0;const w={ENABLE_NOTIFICATIONS:!0,ENABLE_BADGE:!0,NOTIFICATION_TIMEOUT:3e4,BADGE_TIMEOUT:3e5},f=new Map;let b=0,S=[],I=null;function E(e){return e?e.replace(/[=+/]/g,e=>{switch(e){case"=":return"_eq_";case"+":return"_plus_";case"/":return"_slash_";default:return e}}):e}let T=0;const v={DEBUG:0,INFO:1,WARN:2,ERROR:3},R="NETWORK",P="DATABASE",A="AUTH",k="SYSTEM",D="CRITICAL",C="HIGH",O="MEDIUM";class M{constructor(e,t=v.INFO){this.component=e,this.minLevel=t,this.errorCount=0;try{this.isDev=chrome.runtime.getManifest().version_name?.includes("dev"),this.isProduction=!this.isDev}catch(s){this.isDev=!1,this.isProduction=!0}}log(e,t,s=null){if(e<this.minLevel)return;if(this.isProduction&&e<v.WARN)return;const r=Object.keys(v).find(t=>v[t]===e);(new Date).toISOString().substr(11,12),this.component}debug(e,t){this.isDev&&this.log(v.DEBUG,e,t)}info(e,t){this.log(v.INFO,e,t)}warn(e,t){this.log(v.WARN,e,t)}error(e,t){this.errorCount++,this.log(v.ERROR,e,t)}logError(e,t,s,r=null,n={}){this.errorCount++;const a={category:e,severity:t,error:r?{message:r.message,stack:r.stack}:null,context:n,timestamp:(new Date).toISOString()};this.log(v.ERROR,`[${e}][${t}] ${s}`,a),t===D&&this.reportCriticalError(e,s,r,n)}reportCriticalError(e,t,s,r){try{void 0!==q&&q.recordError(this.component,e,D,t,s,r),chrome.storage.local.set({lastCriticalError:{component:this.component,category:e,message:t,error:s?s.message:null,context:r,timestamp:(new Date).toISOString()}})}catch(n){}}getErrorCount(){return this.errorCount}}const N=new M("Scan"),_=new M("DB",v.INFO),$=new M("Cache",v.INFO),x=new M("Network");function F(e,t=null,s={}){const r=t?`${e} (${t})`:e;N.info(r,s)}const q=new class{constructor(){this.errorThreshold=10,this.timeWindow=3e5,this.errorHistory=[],this.criticalErrors=[],this.isShutdownMode=!1}recordError(e,t,s,r,n,a={}){const o={timestamp:Date.now(),component:e,category:t,severity:s,message:r,error:n?{message:n.message,stack:n.stack}:null,context:a};this.errorHistory.push(o),s===D&&(this.criticalErrors.push(o),this.handleCriticalError(o)),this.cleanupOldErrors(),this.checkErrorThreshold()}handleCriticalError(e){N.logError(k,D,`Critical error in ${e.component}: ${e.message}`,e.error,e.context);try{chrome.storage.local.set({criticalErrorLog:this.criticalErrors.slice(-5)})}catch(t){}e.category===A&&this.clearAuthCache(),e.category===P&&this.attemptDatabaseRecovery()}clearAuthCache(){try{chrome.storage.sync.remove(["facebookTokens","userProfile"]),N.warn("Cleared authentication cache due to critical auth error")}catch(e){}}async attemptDatabaseRecovery(){try{o&&(o.close(),o=null),N.warn("Attempted database recovery due to critical DB error")}catch(e){}}checkErrorThreshold(){this.getRecentErrors().length>=this.errorThreshold&&!this.isShutdownMode&&this.enterShutdownMode()}getRecentErrors(){const e=Date.now()-this.timeWindow;return this.errorHistory.filter(t=>t.timestamp>e)}cleanupOldErrors(){const e=Date.now()-this.timeWindow;this.errorHistory=this.errorHistory.filter(t=>t.timestamp>e),this.criticalErrors=this.criticalErrors.filter(t=>t.timestamp>e)}enterShutdownMode(){this.isShutdownMode=!0,N.logError(k,D,"Extension entering shutdown mode due to excessive errors"),s&&c(!1,null),chrome.alarms.clearAll(),void 0!==G?G.createPersistentTimer("exitShutdownMode",6e5,()=>{this.isShutdownMode=!1,N.warn("Exiting shutdown mode - resuming normal operations")}):chrome.alarms.create("exitShutdownMode",{delayInMinutes:10})}getErrorStats(){const e=this.getRecentErrors();return{totalErrors:this.errorHistory.length,recentErrors:e.length,criticalErrors:this.criticalErrors.length,isShutdownMode:this.isShutdownMode,errorsByCategory:this.groupErrorsByCategory(e),errorsByComponent:this.groupErrorsByComponent(e)}}groupErrorsByCategory(e){const t={};return e.forEach(e=>{t[e.category]=(t[e.category]||0)+1}),t}groupErrorsByComponent(e){const t={};return e.forEach(e=>{t[e.component]=(t[e.component]||0)+1}),t}};class L{static withTimeout(e,t,s="operation"){return Promise.race([e,new Promise((e,r)=>setTimeout(()=>r(new Error(`${s} timed out after ${t}ms`)),t))])}static async withRetry(e,t=3,s=1e3,r="operation"){for(let a=1;a<=t;a++)try{return await e()}catch(n){const e=a===t,o=this.isRetryableError(n);if(e||!o)throw N.logError(k,C,`${r} failed after ${a} attempts`,n,{maxRetries:t,attempt:a}),n;N.warn(`${r} failed on attempt ${a}, retrying in ${s}ms`,{error:n.message}),await this.delay(s*a)}}static async withTimeoutAndRetry(e,t,s=3,r="operation"){return this.withRetry(()=>this.withTimeout(e(),t,r),s,1e3,r)}static isRetryableError(e){const t=e.message?.toLowerCase()||"";return t.includes("timeout")||t.includes("network")||t.includes("connection")||t.includes("rate limit")||"TimeoutError"===e.name}static delay(e){return new Promise(t=>setTimeout(t,e))}static async safeAsync(e,t=null,s={}){try{return await e()}catch(r){return N.logError(k,O,"Safe async operation failed, using fallback",r,s),t}}}const U=new class{constructor(){this.metrics=new Map,this.sessions=new Map,this.config={enabled:!0,sampleRate:1,maxHistory:1e3,categories:{database:!0,network:!0,ui:!0,scan:!0,memory:!1}},this.initializeCategories(),N.info("Performance Tracker initialized")}initializeCategories(){["database","network","ui","scan","memory"].forEach(e=>{this.metrics.set(e,{operations:[],totalCount:0,totalDuration:0,avgDuration:0,minDuration:1/0,maxDuration:0,errorCount:0})})}startTimer(e,t,s={}){if(!this.config.enabled||!this.config.categories[e])return null;if(Math.random()>this.config.sampleRate)return null;const r=`${e}_${t}_${Date.now()}_${Math.random()}`,n={category:e,operation:t,metadata:s,startTime:performance.now(),timestamp:(new Date).toISOString()};return this.sessions.set(r,n),r}endTimer(e,t="success",s={}){if(!e||!this.sessions.has(e))return null;const r=this.sessions.get(e),n=performance.now(),a=n-r.startTime,o={...r,endTime:n,duration:a,result:t,additionalData:s};return this.recordMeasurement(o),this.sessions.delete(e),o}recordMeasurement(e){const t=this.metrics.get(e.category);t&&(t.operations.push(e),t.operations.length>this.config.maxHistory&&t.operations.shift(),t.totalCount++,t.totalDuration+=e.duration,t.avgDuration=t.totalDuration/t.totalCount,t.minDuration=Math.min(t.minDuration,e.duration),t.maxDuration=Math.max(t.maxDuration,e.duration),"error"===e.result&&t.errorCount++,e.duration>this.getSlowThreshold(e.category)&&N.warn(`Slow ${e.category} operation: ${e.operation} took ${e.duration.toFixed(2)}ms`))}getSlowThreshold(e){return{database:100,network:5e3,ui:16,scan:1e4,memory:50}[e]||1e3}async timeAsync(e,t,s,r={}){const n=this.startTimer(e,t,r);try{const e=await s();return this.endTimer(n,"success",{result:e}),e}catch(a){throw this.endTimer(n,"error",{error:a.message}),a}}timeSync(e,t,s,r={}){const n=this.startTimer(e,t,r);try{const e=s();return this.endTimer(n,"success",{result:e}),e}catch(a){throw this.endTimer(n,"error",{error:a.message}),a}}getStats(e=null){if(e){const t=this.metrics.get(e);return t?{category:e,...t,errorRate:t.totalCount>0?(t.errorCount/t.totalCount*100).toFixed(2)+"%":"0%",recentOperations:t.operations.slice(-10)}:null}const t={};for(const[s,r]of this.metrics)t[s]={...r,errorRate:r.totalCount>0?(r.errorCount/r.totalCount*100).toFixed(2)+"%":"0%"};return{...t,activeSessions:this.sessions.size,config:this.config}}getReport(){const e=this.getStats(),t={generatedAt:(new Date).toISOString(),summary:{},categories:e};let s=0,r=0,n=0;for(const[a,o]of Object.entries(e))"object"==typeof o&&o.totalCount&&(s+=o.totalCount,r+=o.totalDuration,n+=o.errorCount);return t.summary={totalOperations:s,totalDuration:r.toFixed(2)+"ms",avgDuration:s>0?(r/s).toFixed(2)+"ms":"0ms",totalErrors:n,overallErrorRate:s>0?(n/s*100).toFixed(2)+"%":"0%"},t}configure(e){this.config={...this.config,...e},N.info("Performance Tracker configuration updated",this.config)}reset(){this.initializeCategories(),this.sessions.clear(),N.info("Performance Tracker reset")}captureMemorySnapshot(){if(!this.config.categories.memory)return null;try{if(performance.memory){const e={usedJSHeapSize:performance.memory.usedJSHeapSize,totalJSHeapSize:performance.memory.totalJSHeapSize,jsHeapSizeLimit:performance.memory.jsHeapSizeLimit,timestamp:Date.now()};return this.recordMeasurement({category:"memory",operation:"memorySnapshot",startTime:performance.now(),duration:0,result:"success",additionalData:e,timestamp:(new Date).toISOString()}),e}}catch(e){N.warn("Memory monitoring not available:",e.message)}return null}startMemoryMonitoring(e=3e4){this.config.categories.memory&&(G.createPersistentTimer("memoryMonitoring",e,()=>{this.captureMemorySnapshot()},!0),N.info("Memory monitoring started"))}stopMemoryMonitoring(){G.clearPersistentTimer("memoryMonitoring"),N.info("Memory monitoring stopped")}};const G=new class{constructor(){this.activeTimers=new Map,this.callbacks=new Map}createPersistentTimer(e,t,s,r=!1){this.clearPersistentTimer(e),this.callbacks.set(e,{callback:s,isRepeating:r});const n=Math.max(t/6e4,1),a=r?{periodInMinutes:n}:{delayInMinutes:n};return chrome.alarms.create(e,a),this.activeTimers.set(e,{delayMs:t,isRepeating:r,created:Date.now()}),N.debug(`Created persistent timer: ${e} (${t}ms, repeating: ${r})`),e}createShortTimer(e,t,s){const r=Date.now()+t;this.callbacks.set(e,{callback:s,targetTime:r,isShort:!0});const n=setTimeout(()=>{try{s(),this.clearPersistentTimer(e)}catch(t){N.error(`Short timer callback error for ${e}:`,t)}},t);return chrome.storage.local.set({[`timer_${e}`]:{targetTime:r,delayMs:t,created:Date.now()}}),this.activeTimers.set(e,{timeoutId:n,delayMs:t,isShort:!0,created:Date.now()}),N.debug(`Created hybrid short timer: ${e} (${t}ms)`),e}clearPersistentTimer(e){chrome.alarms.clear(e);const t=this.activeTimers.get(e);t&&t.isShort&&t.timeoutId&&clearTimeout(t.timeoutId),this.activeTimers.delete(e),this.callbacks.delete(e),chrome.storage.local.remove(`timer_${e}`),N.debug(`Cleared persistent timer: ${e}`)}handleAlarm(e){const t=this.callbacks.get(e.name);if(t)try{t.callback(),t.isRepeating||this.clearPersistentTimer(e.name)}catch(s){N.error(`Timer callback error for ${e.name}:`,s)}}async checkShortTimers(){const e=Date.now(),t=await chrome.storage.local.get();for(const[r,n]of Object.entries(t))if(r.startsWith("timer_")&&n.targetTime<=e){const e=r.replace("timer_",""),t=this.callbacks.get(e);if(t&&t.isShort){try{t.callback()}catch(s){N.error(`Short timer callback error for ${e}:`,s)}this.clearPersistentTimer(e)}}}async initialize(){chrome.alarms.onAlarm.hasListener(this.handleAlarm.bind(this))||chrome.alarms.onAlarm.addListener(this.handleAlarm.bind(this)),await this.checkShortTimers(),this.createPersistentTimer("shortTimerCheck",5e3,()=>{this.checkShortTimers()},!0),N.info("ServiceWorkerTimerManager initialized")}};const j=new class{constructor(){this.persistedState={activeScanWindows:new Set,scanProgress:null,activeTimers:new Map,errorState:null,lastActivity:Date.now()},this.persistenceKey="swState_v1",this.stateVersion=1}async persistState(){try{const e={version:this.stateVersion,timestamp:Date.now(),activeScanWindows:Array.from(a),isScanRunning:s,scanStartTime:r,cachedFacebookTokens:h,lastTokenRefresh:d,totalUnreadPosts:b,isGroupFetching:u,lastFetchStartTime:l,performanceStats:U.getStats(),errorStats:q.getErrorStats()};await chrome.storage.local.set({[this.persistenceKey]:e}),N.debug("Service worker state persisted")}catch(e){N.error("Failed to persist service worker state:",e)}}async restoreState(){try{const e=(await chrome.storage.local.get(this.persistenceKey))[this.persistenceKey];if(!e||e.version!==this.stateVersion)return N.info("No compatible persisted state found, starting fresh"),!1;const t=Date.now()-e.timestamp;return t>36e5?(N.warn("Persisted state too old, discarding"),await this.clearPersistedState(),!1):(e.activeScanWindows&&(a.clear(),e.activeScanWindows.forEach(e=>a.add(e))),"boolean"==typeof e.isScanRunning&&(s=e.isScanRunning),e.scanStartTime&&(r=e.scanStartTime),e.cachedFacebookTokens&&(h=e.cachedFacebookTokens),e.lastTokenRefresh&&(d=e.lastTokenRefresh),"number"==typeof e.totalUnreadPosts&&(b=e.totalUnreadPosts),"boolean"==typeof e.isGroupFetching&&(u=e.isGroupFetching),e.lastFetchStartTime&&(l=e.lastFetchStartTime),N.info(`Restored service worker state (age: ${Math.round(t/1e3)}s)`),!0)}catch(e){return N.error("Failed to restore service worker state:",e),!1}}async clearPersistedState(){try{await chrome.storage.local.remove(this.persistenceKey),N.debug("Persisted state cleared")}catch(e){N.error("Failed to clear persisted state:",e)}}startPeriodicPersistence(e=3e4){void 0!==G&&(G.createPersistentTimer("statePersistence",e,()=>{this.persistState()},!0),N.info("Periodic state persistence started"))}async persistOnCriticalEvent(e){N.debug(`Persisting state due to critical event: ${e}`),await this.persistState()}};!async function(){try{await G.initialize(),await j.restoreState(),await async function(){if(!i)try{const{scanState:e}=await chrome.storage.sync.get("scanState");e&&(s=e.isRunning||!1,r=e.startTime||null,s&&r&&Date.now()-r>3e5?(N.warn("Found stale scan state, resetting..."),await c(!1,null)):s&&N.info("Restored active scan state from storage")),i=!0}catch(e){}}(),j.startPeriodicPersistence(),N.info("Service worker initialization complete")}catch(e){}}();const B="https://api.swapify.com/access",z="https://x8ki-letl-twmt.n7.xano.io/api:0tf0mci1/user",V=12e4,H=3,W=1e4;async function K(e){if(!e)return N.error("Cannot check access without user ID"),{hasAccess:!1,status:"unknown",error:"No user ID provided"};try{const t=await J(e);if(t&&Date.now()-t.timestamp<V)return N.info("Using cached access status",t),{hasAccess:t.hasAccess,status:t.status};N.info("Checking user access for ID:",e);const[s,r]=await Promise.all([Q(e),X(e)]),n=!0===s.access&&!0===r.access,a=r.status;let o=null;return n&&("trial"===a?o="trial":"active"===a&&(o="premium")),await async function(e,t,s,r){try{const a={userId:e,hasAccess:t,status:s,tier:r,timestamp:Date.now()};await chrome.storage.sync.set({accessStatus:a});try{await chrome.runtime.sendMessage({type:"subscriptionStatusUpdated",accessStatus:a})}catch(n){}}catch(a){N.error("Failed to cache access status:",a)}}(e,n,a,o),N.info("Access check complete",{hasAccess:n,status:a,tier:o}),{hasAccess:n,status:a,tier:o}}catch(t){N.error("Error checking user access:",t),q.logError(R,C,"Access check failed",t,{userId:e});const s=await J(e);return s?(N.warn("Using expired cached access due to API error"),{hasAccess:s.hasAccess,status:s.status,tier:s.tier}):{hasAccess:!1,status:"error",tier:null,error:t.message}}}async function Q(e){return L.withTimeoutAndRetry(async()=>{const t=await fetch(B,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:e})});if(!t.ok)throw new Error(`swapify API error: ${t.status}`);return await t.json()},W,H,"swapify access check")}async function X(e){return L.withTimeoutAndRetry(async()=>{const t=await fetch(z,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:e})});if(!t.ok)throw new Error(`Xano API error: ${t.status}`);return await t.json()},W,H,"Xano access check")}async function J(e){try{const t=await chrome.storage.sync.get("accessStatus");return t.accessStatus&&t.accessStatus.userId===e?t.accessStatus:null}catch(t){return N.error("Failed to get cached access status:",t),null}}function Y(e){chrome.notifications.create("subscription-required",{type:"basic",iconUrl:chrome.runtime.getURL("assets/images/logo/192x192.png"),title:"Subscription Required",message:e,priority:2,requireInteraction:!0,buttons:[{title:"Subscribe Now"}]})}chrome.notifications.onButtonClicked.addListener(async(e,t)=>{if("subscription-required"===e&&0===t){const{facebookUserId:e}=await chrome.storage.sync.get("facebookUserId"),t=e?`https://swapify.com/subscribe/${encodeURIComponent(e)}`:"https://swapify.com/subscribe/";chrome.tabs.create({url:t})}}),chrome.runtime.onStartup.addListener(async()=>{try{const{facebookUserId:e}=await chrome.storage.sync.get("facebookUserId");e&&await K(e)}catch(e){N.error("Error checking access on startup:",e)}});let Z=null,ee=!1;const te=new class{constructor(){this.pendingOperations=[],this.transactionTimer=null,this.batchDelay=10,_.info("Transaction Manager initialized")}async queueOperation(e,t,s){return new Promise((r,n)=>{this.pendingOperations.push({storeNames:e,mode:t,operation:s,resolve:r,reject:n}),this.transactionTimer||(this.transactionTimer=!0,setTimeout(()=>this.executeBatch(),this.batchDelay))})}async executeBatch(){if(0===this.pendingOperations.length)return;const e=this.pendingOperations.splice(0);_.debug(`Executing batch of ${e.length} operations`);const t=await this.getDatabaseConnection(e);if(!t)return;const s=this.groupOperationsByTransaction(e);for(const[r,n]of s)await this.executeTransactionGroup(t,n);this.transactionTimer=null}async getDatabaseConnection(e){try{return await me()}catch(t){return _.error("Failed to open database",t),this.rejectOperations(e,"Database connection failed: "+t.message),this.transactionTimer=null,null}}groupOperationsByTransaction(e){const t=new Map;return e.forEach(e=>{const s=`${e.storeNames.join(",")}_${e.mode}`;t.has(s)||t.set(s,[]),t.get(s).push(e)}),t}async executeTransactionGroup(e,t){const s=t[0];try{const r=e.transaction(s.storeNames,s.mode),n=this.createObjectStores(r,s.storeNames);this.setupTransactionHandlers(r,t),await this.executeOperations(t,n)}catch(r){_.error("Failed to create transaction",r),this.rejectOperations(t,r.message)}}createObjectStores(e,t){const s={};return t.forEach(t=>{s[t]=e.objectStore(t)}),s}setupTransactionHandlers(e,t){e.onerror=e=>{_.error("Transaction error",e.target.error),this.rejectOperations(t,"Transaction failed: "+e.target.error)},e.onabort=()=>{_.error("Transaction aborted"),this.rejectOperations(t,"Transaction aborted")}}async executeOperations(e,t){for(const r of e)try{const e=await r.operation(t);r.resolve(e)}catch(s){_.error("Operation failed",s),r.reject(s)}}rejectOperations(e,t){e.forEach(e=>{e.reject&&e.reject(new Error(t))})}},se=new class{constructor(){this.cache=new Map,this.cacheExpiry=6e4,this.hits=0,this.misses=0,_.info("Config Service initialized with 1-minute cache")}async getConfig(e,t=null){const s=this.cache.get(e);if(s&&Date.now()-s.time<this.cacheExpiry)return this.hits++,$.debug(`Cache hit for config: ${e}`),s.value;this.misses++,$.debug(`Cache miss for config: ${e}, fetching from DB`);const r=await me(),n=await new Promise(s=>{const n=r.transaction(["config"],"readonly").objectStore("config").getAll();n.onsuccess=()=>{const r=(n.result||[]).find(t=>t.name===e);s(r?.value??t)},n.onerror=()=>s(t)});return this.cache.set(e,{value:n,time:Date.now()}),n}getStats(){const e=this.hits+this.misses;return{hits:this.hits,misses:this.misses,hitRate:e>0?(this.hits/e*100).toFixed(1)+"%":"0%",cacheSize:this.cache.size}}clearCache(){this.cache.clear(),$.debug("Config cache cleared")}};const re=new class{constructor(){this.caches=new Map,this.stats={hits:0,misses:0,invalidations:0},$.info("Cache Manager initialized")}createCache(e,t=3e5){const s={name:e,data:null,timestamp:0,ttlMs:t,hits:0,misses:0};return this.caches.set(e,s),s}async get(e,t){let s=this.caches.get(e);s||(s=this.createCache(e));const r=Date.now(),n=r-s.timestamp>s.ttlMs;if(s.data&&!n)return s.hits++,this.stats.hits++,s.data;s.misses++,this.stats.misses++;try{const e=await t();return s.data=e,s.timestamp=r,e}catch(a){if(s.data)return s.data;throw a}}invalidate(e){const t=this.caches.get(e);t&&(t.data=null,t.timestamp=0,this.stats.invalidations++)}invalidateAll(){this.caches.forEach((e,t)=>{e.data=null,e.timestamp=0}),this.stats.invalidations+=this.caches.size}getStats(){const e={};return this.caches.forEach((t,s)=>{e[s]={hits:t.hits,misses:t.misses,hasData:!!t.data,age:t.data?Math.round((Date.now()-t.timestamp)/1e3):0}}),{global:this.stats,caches:e,hitRate:this.stats.hits+this.stats.misses>0?Math.round(this.stats.hits/(this.stats.hits+this.stats.misses)*100):0}}};re.createCache("groups",3e5),re.createCache("enabledGroups",12e4),re.createCache("keywords",6e5),re.createCache("posts",6e4),re.createCache("recentPosts",3e4);const ne=new class{constructor(){this.requestQueue=[],this.isProcessing=!1,this.stats={totalRequests:0,successfulRequests:0,failedRequests:0,retriedRequests:0,rateLimitHits:0},this.lastRequestTime=0,this.minRequestInterval=1e3,x.info("Network Request Manager initialized")}async executeWithRetry(e,t={}){const{maxRetries:s=3,baseDelay:r=1e3,requestName:n="unknown",bypassQueue:a=!1}=t,o=`${n}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;return a?this.performRequestWithRetry(e,{maxRetries:s,baseDelay:r,requestName:n,requestId:o}):this.queueRequest(e,{...t,requestId:o})}async queueRequest(e,t){return new Promise((s,r)=>{this.requestQueue.push({requestFunction:e,options:t,resolve:s,reject:r,timestamp:Date.now()}),x.debug(` Queued request: ${t.requestName} (Queue size: ${this.requestQueue.length})`),this.isProcessing||this.processQueue()})}async processQueue(){if(!this.isProcessing&&0!==this.requestQueue.length){for(this.isProcessing=!0,x.debug(` Processing queue of ${this.requestQueue.length} requests`);this.requestQueue.length>0;){const{requestFunction:t,options:s,resolve:r,reject:n}=this.requestQueue.shift();try{const e=Date.now()-this.lastRequestTime;if(e<this.minRequestInterval){const t=this.minRequestInterval-e;x.debug(` Rate limiting: waiting ${t}ms before next request`),await new Promise(e=>setTimeout(e,t))}this.lastRequestTime=Date.now();r(await this.performRequestWithRetry(t,s))}catch(e){n(e)}}this.isProcessing=!1,x.debug(" Queue processing complete")}}async performRequestWithRetry(e,t){const{maxRetries:s,baseDelay:r,requestName:n}=t;let a;for(let i=0;i<=s;i++)try{this.stats.totalRequests++,i>0&&await this.handleRetryDelay(i,r,n,s),x.debug(`Executing ${n} (attempt ${i+1}/${s+1})`);const t=await e();return this.updateSuccessStats(n,i),t}catch(o){if(a=o,this.handleRequestError(o,n),!this.shouldRetryRequest(o,i,s,n))throw this.updateFailureStats(n,i),o}throw a}async handleRetryDelay(e,t,s,r){this.stats.retriedRequests++;const n=this.calculateRetryDelay(e,t);x.warn(`Retry ${e}/${r} for ${s} after ${n}ms delay`),await new Promise(e=>setTimeout(e,n))}calculateRetryDelay(e,t){return t*Math.pow(2,e-1)}updateSuccessStats(e,t){this.stats.successfulRequests++,x.info(`âœ… ${e} succeeded on attempt ${t+1}`)}handleRequestError(e,t){this.isRateLimitError(e)&&(this.stats.rateLimitHits++,x.warn(`Rate limit detected for ${t}, increasing delay`),this.adjustRateLimit())}adjustRateLimit(){this.minRequestInterval=Math.min(1.5*this.minRequestInterval,5e3)}shouldRetryRequest(e,t,s,r){return!(t>=s)&&(!!this.isRetryableError(e)&&(x.warn(`âš ï¸ ${r} failed (attempt ${t+1}), will retry: ${e.message}`),!0))}updateFailureStats(e,t){this.stats.failedRequests++,x.error(`âŒ ${e} failed after ${t+1} attempts`)}isRateLimitError(e){const t=e.message?.toLowerCase()||"";return t.includes("rate limit")||t.includes("too many requests")||t.includes("429")||429===e.status}isRetryableError(e){const t=e.message?.toLowerCase()||"";return!(t.includes("authentication")||t.includes("unauthorized")||t.includes("forbidden")||t.includes("not logged in")||t.includes("invalid token"))&&(t.includes("network")||t.includes("timeout")||t.includes("connection")||t.includes("rate limit")||e.status>=500)}getStats(){const e=this.stats.totalRequests>0?Math.round(this.stats.successfulRequests/this.stats.totalRequests*100):0;return{...this.stats,successRate:e+"%",queueSize:this.requestQueue.length,currentInterval:this.minRequestInterval,isProcessing:this.isProcessing}}resetRateLimit(){this.minRequestInterval=1e3,x.debug(" Rate limit reset to default interval")}};chrome.runtime.onInstalled.addListener(async e=>{e.reason});try{chrome.runtime.getManifest().version_name?.includes("dev")&&(globalThis.checkDBOptimizationStats=()=>({config:se.getStats(),memory:re.getStats(),network:ne.getStats()}))}catch(Fe){}async function ae(e=10){return await te.queueOperation(["config"],"readonly",async t=>{const s=t.config;return new Promise((t,r)=>{const n=s.getAll();n.onsuccess=()=>{const s=n.result.filter(e=>e.name&&e.name.startsWith("notification_")).map(e=>e.value).sort((e,t)=>t.timestamp-e.timestamp).slice(0,e);s.filter(e=>!e.read).length,t(s)},n.onerror=()=>{t([])}})})}async function oe(e){e&&e.keywords&&0!==e.keywords.length&&(S.push(e),I&&clearTimeout(I),I=setTimeout(async()=>{S.length>0&&(S.length,_e({type:"batchedNewPosts",posts:S,count:S.length,timestamp:Date.now()}),S=[],I=null)},500))}async function ie(e,t,s){if(!w.ENABLE_NOTIFICATIONS)return;const r=Date.now();if(!(r-T<5e3||(T=r,e=parseInt(e)||0,t=parseInt(t)||0,s=parseInt(s)||0,e<0||t<0||s<0)))if(0!==e)try{const r={type:"scan_summary",title:`Detected ${e} new ${1===e?"lead":"leads"}`,message:`Found ${e} matching ${1===e?"post":"posts"}`,totalMatches:e,totalProcessed:t,groupsScanned:s,read:!1},n=await async function(e){const t=await me();return new Promise((s,r)=>{const n=t.transaction(["config"],"readwrite").objectStore("config"),a=`notification_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,o={name:a,value:{...e,id:a,timestamp:Date.now()}},i=n.add(o);i.onsuccess=()=>{s(o.value)},i.onerror=e=>{e.target.error,r(e.target.error)}})}(r),a=`scan_${Date.now()}`,o={type:"basic",iconUrl:chrome.runtime.getURL("assets/images/logo/192x192.png"),title:`ðŸŽ¯ Detected ${e} new ${1===e?"lead":"leads"}`,message:`Found ${e} new matching ${1===e?"post":"posts"}}`,contextMessage:"Click to view leads in dashboard",priority:2,buttons:[{title:"View Dashboard"},{title:"Dismiss"}]};chrome.notifications.create(a,o,e=>{if(chrome.runtime.lastError)return void chrome.runtime.lastError;const t=setTimeout(()=>{chrome.notifications.clear(e,e=>{chrome.runtime.lastError&&chrome.runtime.lastError})},w.NOTIFICATION_TIMEOUT);globalThis.notificationTimers||(globalThis.notificationTimers=new Map),globalThis.notificationTimers.set(e,t)}),await ue(),_e({type:"newNotification",notification:n,timestamp:Date.now()})}catch(n){}else await ue()}let ce=null;async function ue(e=null){w.ENABLE_BADGE&&(ce&&clearTimeout(ce),ce=setTimeout(async()=>{await async function(e=null){if(null!==e){const t=parseInt(e);e=isNaN(t)||t<0?0:t}try{if(null===e){const t=await Ee();e=t.filter(e=>!e.isRead).length}if(b=e,e>0){const t=e>99?"99+":e.toString();chrome.action.setBadgeText({text:t}),chrome.action.setBadgeBackgroundColor({color:"#ef4444"})}else chrome.action.setBadgeText({text:""})}catch(t){}}(e)},100))}async function le(){if(s&&r&&Date.now()-r>n){const e=s;s=!1,r=null,a.clear(),_e({type:"scanReset",reason:"timeout",wasRunning:e,timestamp:Date.now()}),F("state reset","timeout",{wasRunning:e})}}async function he(e="manual"){const t=s;return await c(!1,null),a.clear(),_e({type:"scanReset",reason:e,wasRunning:t,timestamp:Date.now()}),F("force reset completed",e,{wasRunning:t,nowRunning:!1}),{wasRunning:t,nowRunning:!1}}function de(){return new Promise((e,t)=>{try{const s=indexedDB.open(m,g);s.onupgradeneeded=e=>{const t=e.target.result,s=e.target.transaction,r=e.oldVersion;e.newVersion;s.onerror=e=>{},s.onabort=()=>{};try{if(!t.objectStoreNames.contains("groups")){t.createObjectStore("groups",{keyPath:"id",autoIncrement:!1}).createIndex("url","url",{unique:!0})}if(r<2?(t.objectStoreNames.contains("posts")&&t.deleteObjectStore("posts"),t.createObjectStore("posts",{keyPath:"id",autoIncrement:!1})):t.objectStoreNames.contains("posts")||t.createObjectStore("posts",{keyPath:"id",autoIncrement:!1}),t.objectStoreNames.contains("keywords")||t.createObjectStore("keywords",{keyPath:"id",autoIncrement:!0}),t.objectStoreNames.contains("config")||t.createObjectStore("config",{keyPath:"id",autoIncrement:!0}),!t.objectStoreNames.contains("scanned_posts")){const e=t.createObjectStore("scanned_posts",{keyPath:"id"});e.createIndex("groupId","groupId",{unique:!1}),e.createIndex("scannedAt","scannedAt",{unique:!1})}}catch(n){s.abort()}},s.onsuccess=t=>{o=t.target.result,o.onerror=e=>{e.target.error},o.onclose=()=>{o=null},e(o)},s.onerror=e=>{e.target.error,t(new Error(`Failed to open database: ${e.target.error}`))},s.onblocked=e=>{t(new Error("Database blocked by another connection"))}}catch(s){t(s)}})}async function me(){return U.timeAsync("database","openDatabase",async()=>L.withRetry(async()=>(o&&"done"!==o.readyState||(_.info("Database not open, initializing..."),await de()),o),3,100,"database initialization")).catch(e=>{throw _.logError(P,D,"Failed to open database after retries",e),e})}async function ge(s=!1){const r=await async function(){return new Promise(e=>{try{chrome.storage.sync.get(["scanInterval"],s=>{if(chrome.runtime.lastError)return chrome.runtime.lastError,void e(t);const r=parseInt(s.scanInterval)||t;e(r<1||r>10080?t:r)})}catch(s){e(t)}})}();await chrome.alarms.clear(e),chrome.alarms.create(e,{periodInMinutes:r,delayInMinutes:s?0:r})}async function pe(){try{return await re.get("groups",async()=>{const e=Date.now(),t=await me(),s=await new Promise((e,s)=>{const r=t.transaction(["groups"],"readonly").objectStore("groups").getAll();r.onsuccess=()=>e(r.result),r.onerror=()=>s(r.error)});Date.now();return s})}catch(e){const t=await me();return new Promise((e,s)=>{const r=t.transaction(["groups"],"readonly").objectStore("groups").getAll();r.onsuccess=()=>{e(r.result)},r.onerror=e=>{s(e.target.error)}})}}async function ye(){try{return await re.get("keywords",async()=>{const e=Date.now(),t=await me(),s=await new Promise((e,s)=>{const r=t.transaction(["keywords"],"readonly").objectStore("keywords").getAll();r.onsuccess=()=>e(r.result),r.onerror=()=>s(r.error)});Date.now();return s})}catch(e){const t=await me();return new Promise((e,s)=>{const r=t.transaction(["keywords"],"readonly").objectStore("keywords").getAll();r.onsuccess=()=>{e(r.result)},r.onerror=e=>{s(e.target.error)}})}}async function we(){Date.now();const e={postsPerScan:18,scanIntervalMinutes:120};try{const t=await se.getConfig("postsPerScan")||e.postsPerScan,s=await se.getConfig("keywordMatchType")||"includes",r={postsPerScan:parseInt(t)||e.postsPerScan,scanIntervalMinutes:e.scanIntervalMinutes,keywordMatchType:s};return r.postsPerScan,r.keywordMatchType,r}catch(t){return e}}async function fe(e){if(!e||0===e.length)return{success:!0,saved:0};!function(e,t,s=null){const r=s?`${e}: ${t} groups - ${s}`:`${e}: ${t} groups`;_.info(r)}("Saving to database",e.length);const t=await te.queueOperation(["groups"],"readwrite",async t=>{const s=t.groups;let r=0,n=[];for(let o=0;o<e.length;o++){const t=e[o];try{(!t.lastVisited||"number"!=typeof t.lastVisited||t.lastVisited<=0)&&(t.lastVisited=Date.now());const n=await new Promise(e=>{const r=s.get(t.id);r.onsuccess=()=>e(r.result),r.onerror=()=>e(null)});if(n){!n.lastVisited||"number"!=typeof n.lastVisited||n.lastVisited<=0||t.lastVisited&&t.lastVisited>n.lastVisited?(n.name=t.name,n.lastVisited=t.lastVisited,void 0!==t.enabled&&(n.enabled=t.enabled),await new Promise((a,o)=>{const i=s.put(n);i.onsuccess=()=>{r++,e.length,t.name,n.enabled,a()},i.onerror=()=>o(i.error)})):(r++,e.length,t.name)}else void 0===t.enabled&&(t.enabled=!1),await new Promise((n,a)=>{const o=s.put(t);o.onsuccess=()=>{r++,e.length,t.name,t.enabled,n()},o.onerror=()=>a(o.error)})}catch(a){n.push({group:t.name,error:a}),t.name}}return{success:!0,saved:r,errors:n.length}});try{chrome.runtime.sendMessage({type:"groupsSaved",count:t.saved})}catch(s){!function(e,t){N.error(`Could not notify UI of ${e}`,t)}("groups saved",s)}return re.invalidate("groups"),re.invalidate("enabledGroups"),t}async function be(e){const t=U.startTimer("database","savePost",{postId:e.id});try{const s=Date.now(),r=await me(),n=await new Promise((t,s)=>{const n=r.transaction(["posts"],"readwrite"),a=n.objectStore("posts"),o=setTimeout(()=>{s(new Error("Database transaction timeout"))},5e3);n.oncomplete=()=>clearTimeout(o),n.onerror=()=>{clearTimeout(o),s(n.error)};const i=E(e.id),c=a.get(i);c.onsuccess=()=>{if(c.result)return e.id,clearTimeout(o),y++,void t({...c.result,isExisting:!0});const r={...e,id:i,originalId:e.id,isRead:!1},n=a.add(r);n.onsuccess=()=>{e.id,clearTimeout(o),p++,t({...r,isNew:!0})},n.onerror=()=>{"ConstraintError"===n.error.name?(e.id,clearTimeout(o),t(r)):(clearTimeout(o),s(n.error))}},c.onerror=()=>{clearTimeout(o),s(c.error)}});Date.now();return n&&n.keywords&&n.keywords.length>0&&n.isNew?oe(n):n&&n.keywords&&n.keywords.length>0&&n.isExisting,U.endTimer(t,"success"),n}catch(s){const r=await me(),n=await new Promise((t,s)=>{const n=r.transaction(["posts"],"readwrite").objectStore("posts"),a=E(e.id),o=n.get(a);o.onsuccess=()=>{const r=o.result;if(r)return e.id,void t({...r,isExisting:!0});const i={...e,id:a,originalId:e.id,isRead:!1},c=n.put(i);c.onsuccess=async()=>{i.keywords&&i.keywords.length>0&&oe(i),p++,t({...i,isNew:!0})},c.onerror=e=>{e.target.error,s(e.target.error)}},o.onerror=e=>{e.target.error,s(e.target.error)}});return U.endTimer(t,"success"),n}}async function Se(e,t){try{const s=Date.now(),r=await te.queueOperation(["groups"],"readwrite",async s=>{const r=s.groups,n=await new Promise((t,s)=>{const n=r.get(e);n.onsuccess=()=>t(n.result),n.onerror=()=>s(n.error)});return n?(n.scannedPosts=(n.scannedPosts||0)+t,n.lastScanTime=Date.now(),await new Promise((e,t)=>{const s=r.put(n);s.onsuccess=()=>e(),s.onerror=()=>t(s.error)}),n):null});Date.now();return r&&r.name,r}catch(s){const r=await me();return new Promise((s,n)=>{const a=r.transaction(["groups"],"readwrite").objectStore("groups"),o=a.get(e);o.onsuccess=()=>{const e=o.result;if(e){e.scannedPosts=(e.scannedPosts||0)+t,e.lastScanTime=Date.now();const r=a.put(e);r.onsuccess=()=>{s(e)},r.onerror=e=>{n(e.target.error)}}else s(null)},o.onerror=e=>{n(e.target.error)}})}}async function Ie(){if(u)return!1;try{u=!0,l=Date.now();try{const t=await new Promise(e=>{chrome.runtime.sendMessage({type:"GET_USER_PROFILE_VIA_IFRAME"},t=>{chrome.runtime.lastError?e({success:!1}):e(t)})});if(!t?.profile?.isSignedIn){u=!1,function(e){try{chrome.runtime.sendMessage({type:"facebookLoginStatus",isSignedIn:e})}catch(t){t.message}}(!1);try{chrome.runtime.sendMessage({type:"groupFetchingCompleted"})}catch(e){}return!0}}catch(e){}try{chrome.runtime.sendMessage({type:"groupFetchingStarted"})}catch(e){e.message}const t=await new Promise((e,t)=>{chrome.runtime.sendMessage({type:"FETCH_GROUPS_VIA_IFRAME"},s=>{chrome.runtime.lastError?t(new Error(chrome.runtime.lastError.message)):e(s)})});if(!t||!t.success)throw new Error(t?.error||"Failed to fetch groups via iframe");t.groups&&t.groups.length>0&&(await fe(t.groups),await xe("lastGroupFetch",Date.now()),t.groups.length),u=!1;try{chrome.runtime.sendMessage({type:"groupFetchingCompleted"})}catch(e){e.message}return!0}catch(e){const s=e.message||"";s.includes("authentication")||s.includes("logged into Facebook")||s.includes("fb_dtsg"),u=!1;try{chrome.runtime.sendMessage({type:"groupFetchingCompleted",error:e.message})}catch(t){t.message}return!1}}async function Ee(){return await te.queueOperation(["posts"],"readonly",async e=>{const t=e.posts;return new Promise((e,s)=>{const r=t.getAll();r.onsuccess=()=>e(r.result),r.onerror=()=>s(r.error)})})}async function Te(e){const t=await me();try{const s={timestamp:e.timestamp||Date.now(),groupId:e.groupId||null,totalProcessed:e.totalProcessed||0,totalMatches:e.totalMatches||0,scanType:e.scanType||"manual",groupsScanned:e.groupsScanned||1},r=t.transaction(["config"],"readwrite").objectStore("config"),n=`scan_${Date.now()}`;await new Promise((e,t)=>{const a=r.add({name:n,value:s});a.onsuccess=()=>{e()},a.onerror=e=>{e.target.error,t(e.target.error)}})}catch(s){}}async function ve(e){try{const t=await me();return new Promise((s,r)=>{const n=t.transaction(["posts"],"readwrite"),a=n.objectStore("posts");n.onerror=()=>{n.error,r(n.error)},n.onabort=()=>{r(new Error("Transaction aborted"))};const o=E(e),i=a.get(o);i.onsuccess=()=>{const e=i.result;if(e){e.isRead=!0;const t=a.put(e);t.onsuccess=()=>{try{ue()}catch(e){}s()},t.onerror=()=>{t.error,r(t.error)}}else s()},i.onerror=()=>{i.error,r(i.error)}})}catch(t){throw t}}chrome.notifications.onClicked.addListener(e=>{const t=Array.from(f.values()).find(t=>t.notificationId===e);t&&t.post.url?chrome.tabs.create({url:t.post.url}):chrome.tabs.create({url:chrome.runtime.getURL("index.html")}),chrome.notifications.clear(e)}),chrome.notifications.onButtonClicked.addListener((e,t)=>{const s=Array.from(f.values()).find(t=>t.notificationId===e);0===t?s&&s.post.url&&chrome.tabs.create({url:s.post.url}):1===t&&chrome.tabs.create({url:chrome.runtime.getURL("index.html")}),chrome.notifications.clear(e)}),void 0!==G?(G.createPersistentTimer("scanHeartbeat",6e4,le,!0),N.info("Scan heartbeat monitoring initialized with persistent timer")):setTimeout(()=>{G.createPersistentTimer("scanHeartbeat",6e4,le,!0),N.info("Scan heartbeat monitoring initialized (delayed)")},1e3),self.addEventListener("deactivate",()=>{void 0!==G&&G.clearPersistentTimer("scanHeartbeat"),void 0!==j&&j.persistOnCriticalEvent("serviceWorkerDeactivate").catch(e=>console.error("[FB Keyword Monitor] Error persisting state on deactivation:",e))}),self.addEventListener("activate",e=>{e.waitUntil((async()=>{try{void 0!==G&&void 0!==j&&await j.restoreState()}catch(e){}})())}),self.addEventListener("install",e=>{self.skipWaiting()}),chrome.runtime.onInstalled.addListener(async e=>{await ge(!1),e.reason===chrome.runtime.OnInstalledReason.INSTALL&&chrome.tabs.create({url:chrome.runtime.getURL("index.html")})}),chrome.alarms.onAlarm.addListener(async t=>{if(t.name===e&&!s){await c(!0,Date.now());try{await Me()}catch(r){await c(!1,null),F("flag reset","scheduled scan error")}}}),chrome.runtime.onMessage.addListener((e,t,o)=>{if(e.type,"ping"!==e.type){if("checkUserAccess"===e.type)return e.userId,K(e.userId).then(e=>{o({success:!0,hasAccess:e.hasAccess,status:e.status})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("checkFacebookLoginViaCookie"===e.type)return async function(){try{const{isDemoMode:e}=await chrome.storage.sync.get("isDemoMode");if(e){const e="12345";return N.info("Demo mode active - returning mock user ID:",e),Z=e,e}const t=(await new Promise((e,t)=>{chrome.cookies.getAll({},s=>{chrome.runtime.lastError?t(chrome.runtime.lastError):e(s)})})).filter(e=>e.domain.includes("facebook.com")),s=t.find(e=>"c_user"===e.name);let r=null;try{r=t.find(e=>"i_user"===e.name)}catch(Fe){}const n=r?.value||s?.value||null;return n===r?.value&&r&&!ee&&(ee=!0,N.warn("You are interacting as a Facebook page. This can be buggy! Please switch to personal Facebook account if you are facing issues.")),n?(N.info("Facebook user ID found via cookie:",n),Z&&Z!==n&&N.info("Facebook user ID changed from",Z,"to",n),Z=n):(N.warn("No Facebook user ID found in cookies - user may not be logged in"),Z&&N.warn("User was previously logged in as",Z),Z=null),n}catch(e){return N.error("Error checking Facebook login via cookie:",e),null}}().then(e=>{o({success:!0,userId:e,isLoggedIn:!!e})}).catch(e=>{o({success:!1,error:e.message,isLoggedIn:!1,userId:null})}),!0;if("trigger-scan"===e.type)return s?void o({success:!1,reason:"scan_already_running"}):void o({success:!0,message:"Scheduled scan triggered"});if("getGroups"===e.type)return pe().then(e=>{o({success:!0,groups:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getKeywords"===e.type)return ye().then(e=>{o({success:!0,keywords:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getPosts"===e.type)return Ee().then(e=>{o({success:!0,posts:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getPostsByGroup"===e.type)return async function(e){return await te.queueOperation(["posts"],"readonly",async t=>{const s=t.posts;return new Promise((t,r)=>{const n=s.getAll();n.onsuccess=()=>{const s=n.result.filter(t=>t.groupId===e);s.length,t(s)},n.onerror=()=>r(n.error)})})}(e.groupId).then(e=>{o({success:!0,posts:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getScannedPostIds"===e.type)return async function(e){return await te.queueOperation(["scanned_posts"],"readonly",async t=>{const s=t.scanned_posts.index("groupId");return new Promise((t,r)=>{const n=s.getAll(e);n.onsuccess=()=>{const e=n.result.sort((e,t)=>t.scannedAt-e.scannedAt).slice(0,3);e.length,t(e)},n.onerror=()=>{n.error,r(n.error)}})})}(e.groupId).then(e=>{o({success:!0,scannedPosts:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getAllScannedPostIds"===e.type)return async function(e){return await te.queueOperation(["scanned_posts"],"readonly",async t=>{const s=t.scanned_posts.index("groupId");return new Promise((t,r)=>{const n=s.getAll(e);n.onsuccess=()=>{const e=n.result,s=new Set(e.map(e=>e.id));s.size,s.size>0&&Array.from(s)[0],t(s)},n.onerror=()=>{n.error,r(n.error)}})})}(e.groupId).then(e=>{const t=Array.from(e);o({success:!0,postIds:t})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveScannedPostIds"===e.type){e.groupId,e.postIds.length;const t=e.postIds.map(t=>async function(e,t,s){return await te.queueOperation(["scanned_posts"],"readwrite",async r=>{const n=r.scanned_posts,a={id:e,groupId:t,scannedAt:Date.now(),scanOrder:s};return new Promise((e,t)=>{const s=n.put(a);s.onsuccess=()=>{e()},s.onerror=()=>{s.error,t(s.error)}})})}(t.postId,e.groupId,t.scanOrder));return Promise.all(t).then(()=>(e.postIds.length,async function(e){const t=await me();return new Promise((s,r)=>{const n=t.transaction(["scanned_posts"],"readwrite").objectStore("scanned_posts"),a=n.index("groupId").getAll(e);a.onsuccess=e=>{const t=e.target.result;if(t.length,t.length<=3)return t.length,void s(0);const r=t.sort((e,t)=>e.scanOrder-t.scanOrder),a=r.slice(0,3),o=r.slice(3);o.length,a.map(e=>e.id),o.map(e=>e.id);let i=0;const c=o.map(e=>new Promise(t=>{const s=n.delete(e.id);s.onsuccess=()=>{i++,t()},s.onerror=()=>t()}));Promise.all(c).then(()=>{s(i)})},a.onerror=e=>{e.target.error,r(e.target.error)}})}(e.groupId))).then(e=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0}if("checkPostInDatabase"===e.type)return async function(e,t){Date.now();try{return await te.queueOperation(["scanned_posts"],"readonly",async s=>{const r=s.scanned_posts.index("groupId");return new Promise((s,n)=>{const a=r.getAll(t);a.onsuccess=()=>{const t=a.result;t.length,t.length>0&&t.map(e=>e.id);const r=t.some(t=>t.id===e);s(r)},a.onerror=()=>{a.error,n(a.error)}})})}catch(s){return!1}}(e.postId,e.groupId).then(e=>{o({exists:e})}).catch(e=>{o({exists:!1})}),!0;if("saveKeyword"===e.type)return async function(e){return await te.queueOperation(["keywords"],"readwrite",async t=>{const s=t.keywords,r={term:e.term,isPositive:!1!==e.isPositive};return new Promise((e,t)=>{const n=s.add(r);n.onsuccess=()=>{re.invalidate("keywords"),e(r)},n.onerror=()=>{n.error,t(n.error)}})})}(e.keyword).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveAIDescription"===e.type)return xe("aiPostDescription",e.description).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveGroup"===e.type)return async function(e){const t=await me();return new Promise((s,r)=>{const n=t.transaction(["groups"],"readwrite").objectStore("groups");(!e.lastVisited||"number"!=typeof e.lastVisited||e.lastVisited<=0)&&(e.lastVisited=Date.now());const a=n.get(e.id);a.onsuccess=t=>{if(t.target.result){const a=t.target.result;if(!a.lastVisited||"number"!=typeof a.lastVisited||a.lastVisited<=0||e.lastVisited&&e.lastVisited>a.lastVisited){a.name=e.name,a.lastVisited=e.lastVisited,void 0!==e.enabled&&(a.enabled=e.enabled);const t=n.put(a);t.onsuccess=()=>{re.invalidate("groups"),re.invalidate("enabledGroups"),s()},t.onerror=e=>{e.target.error,r(e.target.error)}}else a.name,s()}else{const t=n.put(e);t.onsuccess=()=>{re.invalidate("groups"),re.invalidate("enabledGroups"),s()},t.onerror=e=>{e.target.error,r(e.target.error)}}},a.onerror=e=>{e.target.error,r(e.target.error)}})}(e.group).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveAllGroups"===e.type)return fe(e.groups).then(e=>{o({success:!0,result:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("savePost"===e.type)return be(e.post).then(e=>{e.isNew?(_e({type:"postSavedDuringScanning",post:e,timestamp:Date.now()}),e.id):e.isExisting&&e.id}).catch(e=>{}),o({success:!0,message:"Save initiated"}),!1;if("postsScanned"===e.type)return e.posts.length,e.groupId,Promise.all(e.posts.map(e=>be(e))).then(e=>{const t=e.filter(e=>e.isNew),s=e.filter(e=>e.isExisting);p+=t.length,y+=s.length;t.forEach(n=>{_e({type:"postSavedDuringScanning",post:n,timestamp:Date.now()})});o({success:!0,savedCount:e.length,newCount:t.length})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("deletePost"===e.type)return async function(e){return U.timeAsync("database","deletePost",async()=>await te.queueOperation(["posts"],"readwrite",async t=>{const s=t.posts;return new Promise((t,r)=>{const n=s.delete(e);n.onsuccess=()=>{re.invalidate("posts"),re.invalidate("recentPosts"),t({success:!0,deletedId:e})},n.onerror=()=>{n.error,r(n.error)}})}),{postId:e})}(e.postId).then(e=>{o({success:!0,result:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("resetAllGroups"===e.type)return async function(){const e=await me();return new Promise((t,s)=>{const r=e.transaction(["groups"],"readwrite").objectStore("groups"),n=r.getAll();n.onsuccess=async()=>{const e=n.result;let s=0;for(const t of e)!1!==t.enabled&&(t.enabled=!1,await new Promise((e,n)=>{const a=r.put(t);a.onsuccess=()=>{s++,e()},a.onerror=()=>n(a.error)}));re.invalidate("groups"),re.invalidate("enabledGroups"),t(s)},n.onerror=()=>s(n.error)})}().then(e=>{o({success:!0,count:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("updateGroupEnabled"===e.type)return async function(e,t){Date.now();try{if(t){const{facebookUserId:e}=await chrome.storage.sync.get("facebookUserId");if(e){const t=await Oe(e);if(!t.canEnable){const e=new Error(`You've reached your limit of ${t.maxAllowed} monitored groups. Please upgrade your subscription to monitor more groups.`);throw e.code="GROUP_LIMIT_EXCEEDED",e.details=t,e}}}const s=await me();await new Promise((r,n)=>{const a=s.transaction(["groups"],"readwrite").objectStore("groups"),o=a.get(e);o.onsuccess=()=>{const e=o.result;if(e){e.enabled=t;const s=a.put(e);s.onsuccess=()=>{re.invalidate("groups"),re.invalidate("enabledGroups"),r()},s.onerror=()=>{s.error,n(s.error)}}else n(new Error("Group not found"))},o.onerror=()=>n(o.error)})}catch(s){throw s}}(e.groupId,e.enabled).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message,code:e.code,details:e.details})}),!0;if("getGroupLimits"===e.type)return chrome.storage.sync.get("facebookUserId").then(({facebookUserId:e})=>e?Promise.all([Oe(e),Pe(e)]):(o({success:!1,error:"No Facebook user ID found"}),Promise.reject(new Error("No Facebook user ID found")))).then(([e,t])=>{o({success:!0,monitorLimit:e,maxGroupsPerScan:t})}).catch(e=>{"No Facebook user ID found"!==e.message&&o({success:!1,error:e.message})}),!0;if("visitGroup"===e.type)return async function(e){try{return(await chrome.tabs.create({url:e})).id,!0}catch(t){return!1}}(e.url).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("fetchAllGroups"===e.type)return Ie().then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("scanGroupGraphQL"===e.type)return e.groupId,scanSingleGroup(e.groupId,e.tokens,e.settings).then(e=>{o({success:!0,posts:e.posts||[],matches:e.matches||[]})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("scanCompleted"===e.type){e.results,void 0!==j&&j.persistOnCriticalEvent("scanComplete").catch(e=>console.error("[FB Keyword Monitor] Error persisting state on scan completion:",e));const t=e.scanId;if(!t)return void o({success:!1,error:"Missing scan ID"});I&&(clearTimeout(I),I=null),S.length>0&&(S.length,_e({type:"batchedNewPosts",posts:S,count:S.length,timestamp:Date.now()}),S=[]),Te(e.results);const{totalMatches:s=0,totalProcessed:r=0,groupsScanned:n=0}=e.results,a=p;return ie(a,r,n).catch(e=>{}),chrome.tabs.query({url:chrome.runtime.getURL("scan.html")},s=>{s.length>0&&chrome.tabs.sendMessage(s[0].id,{type:"scanCompleted",scanId:t,results:e.results}).catch(e=>{e.message})}),Ce().then(()=>{}).catch(e=>{}),c(!1,null).then(()=>{F("flag reset","scan completed")}).catch(e=>{F("flag reset","scan completed with error")}),e.results&&e.results.groupId&&e.results.totalProcessed?Se(e.results.groupId,e.results.totalProcessed).then(e=>{o({success:!0,updatedGroup:e})}).catch(e=>{o({success:!0})}):o({success:!0}),!0}if("scanError"===e.type)return e.error,void 0!==j&&j.persistOnCriticalEvent("scanError").catch(e=>console.error("[FB Keyword Monitor] Error persisting state on scan error:",e)),Ce().then(()=>{}).catch(e=>{}),c(!1,null).then(()=>{F("flag reset","scan error")}).catch(e=>{F("flag reset","scan error with state update error")}),o({success:!0}),!0;if("scanProgress"===e.type){const t=e.scanId;return t?(o({success:!0}),void chrome.tabs.query({url:chrome.runtime.getURL("scan.html")},s=>{s.length>0&&chrome.tabs.sendMessage(s[0].id,{type:"scanProgress",scanId:t,current:e.current,total:e.total,groupName:e.groupName,status:e.status}).catch(e=>{e.message})})):void o({success:!1,error:"Missing scan ID"})}if("updateGroupScanStats"===e.type)return e.groupId,e.scannedCount,Se(e.groupId,e.scannedCount).then(()=>{_e({type:"scanStatsUpdated",groupId:e.groupId,scannedCount:e.scannedCount,timestamp:Date.now()}),o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveScanResults"===e.type)return e.results,Te(e.results).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getConfig"===e.type)return $e(e.name).then(e=>{o({success:!0,value:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveConfig"===e.type)return xe(e.name,e.value).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("extractDynamicValues"===e.type)return chrome.tabs.query({url:"*://www.facebook.com/*"},e=>{if(e.length>0){const t=e[0];chrome.tabs.sendMessage(t.id,{type:"extractDynamicValues"},e=>{chrome.runtime.lastError?(chrome.runtime.lastError.message,o({success:!1,error:"Content script not available"})):e&&e.success?o({success:!0,values:e.values}):o({success:!1,error:"Extraction failed"})})}else o({success:!1,error:"No Facebook tabs found"})}),!0;if("getScanSettings"===e.type)return we().then(e=>{o({success:!0,settings:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("openExtensionPage"===e.type)return chrome.tabs.create({url:chrome.runtime.getURL("index.html")}),o({success:!0}),!0;if("resetScanFlag"===e.type)return s=!1,o({success:!0,message:"Scan flag reset"}),!0;if("updateScanInterval"===e.type){const t=e.intervalMinutes;return chrome.storage.sync.set({scanInterval:t},()=>{chrome.runtime.lastError?(chrome.runtime.lastError,o({success:!1,error:chrome.runtime.lastError.message})):ge(!1).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})})}),!0}if("resetNextScanTime"===e.type)return ge(!1).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getGroupFetchingStatus"===e.type)return u&&Date.now()-l>3e4&&(u=!1),o({isFetching:u}),!0;if("startManualScan"===e.type)return o({success:!0,message:"Manual scan handled"}),!0;if("startBackgroundScan"===e.type)return s?void o({success:!1,error:"scan_already_running"}):(c(!0,Date.now()).then(()=>Me()).then(()=>{o&&o({success:!0,message:"Iframe-based scan started"})}).catch(e=>{c(!1,null),o&&o({success:!1,error:e.message})}),!0);if("resetScanFlag"===e.type)return he("manual").then(e=>{o({success:!0,wasRunning:e.wasRunning,nowRunning:e.nowRunning})}),!0;if("getPerformanceReport"===e.type){try{const e=U.getReport(),t=re.getStats(),s=ne.getStats(),r={...e,additionalMetrics:{memoryCache:t,networkManager:s,activeSessions:U.sessions.size,reportGeneratedAt:(new Date).toISOString()}};o({success:!0,report:r})}catch(i){o({success:!1,error:i.message})}return!0}if("forceResetScan"===e.type)return he(e.reason||"force").then(e=>{o({success:!0,wasRunning:e.wasRunning,nowRunning:e.nowRunning})}),!0;if("checkScanStatus"===e.type)return s&&r&&Date.now()-r>n&&(s=!1,r=null),void o({success:!0,isRunning:s,scanStartTime:r,activeScanWindows:a.size,timestamp:Date.now()});if("scanWindowClosing"===e.type)return e.reason,s&&e.reason.includes("User action")&&(s=!1,r=null,a.clear(),Ce().then(()=>{}).catch(e=>{}),_e({type:"scanCancelled",reason:"User closed scan window",timestamp:Date.now()})),void o({success:!0});if("updateBadgeCount"===e.type)return ue().then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("saveScanProgress"===e.type)return e.groupId,chrome.storage.sync.get("facebookUserId").then(({facebookUserId:t})=>{if(t)return async function(e,t,s,r){try{const n={currentGroupId:e,currentIndex:t,totalGroups:s,userId:r,timestamp:Date.now()};await chrome.storage.sync.set({[Re.SCAN_PROGRESS_KEY]:n})}catch(i){}}(e.groupId,e.groupIndex,e.totalGroups,t);o({success:!1,error:"No user ID"})}).then(()=>{o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("getAlertSettings"!==e.type){if("updateAlertSettings"===e.type)return e.settings,void 0!==e.settings.notifications&&(w.ENABLE_NOTIFICATIONS=e.settings.notifications),void 0!==e.settings.badge&&(w.ENABLE_BADGE=e.settings.badge),chrome.storage.sync.set({alertSettings:{notifications:w.ENABLE_NOTIFICATIONS,badge:w.ENABLE_BADGE}}),void o({success:!0});if("getRecentNotifications"===e.type)return ae(e.limit||10).then(e=>{o({success:!0,notifications:e})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("markNotificationAsRead"===e.type)return e.notificationId,(async()=>{try{const t=await $e(e.notificationId);t&&(t.read=!0,await xe(e.notificationId,t)),await ue(),o({success:!0})}catch(i){o({success:!1,error:i.message})}})(),!0;if("markAllNotificationsAsRead"===e.type)return ae(50).then(async e=>{for(const t of e)t.read||(t.read=!0,await xe(t.id,t));o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("markPostAsRead"===e.type)return e.postId,ve(e.postId).then(()=>{setTimeout(()=>{ue()},100),o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("markAllPostsAsRead"===e.type)return async function(){return new Promise(async(e,t)=>{try{const s=(await me()).transaction(["posts"],"readwrite").objectStore("posts"),r=s.getAll();r.onsuccess=()=>{const n=r.result.filter(e=>!e.isRead).map(e=>new Promise((t,r)=>{e.isRead=!0;const n=s.put(e);n.onsuccess=()=>{t()},n.onerror=()=>{r(n.error)}}));Promise.all(n).then(()=>{ue(),e()}).catch(t)},r.onerror=()=>{r.error,t(r.error)}}catch(i){t(i)}})}().then(()=>{setTimeout(()=>{ue()},100),o({success:!0})}).catch(e=>{o({success:!1,error:e.message})}),!0;if("testNotification"!==e.type);else{if(!w.ENABLE_NOTIFICATIONS)return void o({success:!1,error:"Notifications are disabled in settings"});try{const t=`test_${Date.now()}`,s={type:"basic",iconUrl:chrome.runtime.getURL("assets/images/logo/192x192.png"),title:e.title||"ðŸ§ª Test Notification",message:e.message||"This is a test notification from the console",contextMessage:"Console test notification",priority:2};chrome.notifications.create(t,s),setTimeout(()=>{chrome.notifications.clear(t)},w.NOTIFICATION_TIMEOUT),o({success:!0,notificationId:t})}catch(i){o({success:!1,error:i.message})}}}else o({success:!0,settings:{notifications:w.ENABLE_NOTIFICATIONS,badge:w.ENABLE_BADGE,notificationTimeout:w.NOTIFICATION_TIMEOUT,badgeTimeout:w.BADGE_TIMEOUT}})}else o({success:!0,ready:!0})}),chrome.storage.onChanged.addListener((e,t)=>{"sync"===t&&e.scanInterval&&ge(!1)}),chrome.action.onClicked.addListener(e=>{chrome.tabs.create({url:chrome.runtime.getURL("index.html")})});const Re={MAX_GROUPS_PER_SCAN:5,ALTERNATOR_CACHE_PREFIX:"fb_alternator_",SCAN_PROGRESS_KEY:"fb_scan_progress",TIER_LIMITS:{trial:3,premium:10},MAX_GROUPS_TO_MONITOR:{trial:3,premium:25}};async function Pe(e){try{const t=await J(e);if(t&&t.tier){const e=Re.TIER_LIMITS[t.tier];if(e)return t.tier,e}const{subscriptionMaxGroups:s}=await chrome.storage.sync.get("subscriptionMaxGroups");if(s)return s}catch(t){}return Re.MAX_GROUPS_PER_SCAN,Re.MAX_GROUPS_PER_SCAN}function Ae(e){const t=[...e];for(let s=t.length-1;s>0;s--){const e=Math.floor(Math.random()*(s+1));[t[s],t[e]]=[t[e],t[s]]}return t}async function ke(e,t){const s=`${Re.ALTERNATOR_CACHE_PREFIX}${e}`;try{await chrome.storage.local.set({[s]:t})}catch(r){}}async function De(e,t,s=Re.MAX_GROUPS_PER_SCAN){try{const r=await async function(e){const t=`${Re.ALTERNATOR_CACHE_PREFIX}${e}`;try{const e=await chrome.storage.local.get(t);if(e[t]&&Array.isArray(e[t]))return e[t];const s=await chrome.storage.sync.get(t);if(s[t]&&Array.isArray(s[t]))return await chrome.storage.local.set({[t]:s[t]}),await chrome.storage.sync.remove(t),s[t]}catch(s){}return[]}(t);r.length;let n=e.filter(e=>!r.includes(e.id));0===n.length&&(await ke(t,[]),n=e);const a=Ae(n).slice(0,s),o=[...r,...a.map(e=>e.id)];return await ke(t,o),a.length,e.length,a.map(e=>`${e.id} - ${e.name}`).join(", "),a}catch(r){return e.slice(0,s)}}async function Ce(){try{await chrome.storage.sync.remove(Re.SCAN_PROGRESS_KEY)}catch(e){}}async function Oe(e){try{const t=await async function(){try{return(await pe()).filter(e=>!0===e.enabled).length}catch(e){return 0}}(),s=await async function(e){try{const t=await J(e);if(t&&t.tier){const e=Re.MAX_GROUPS_TO_MONITOR[t.tier];if(e)return t.tier,e}const{subscriptionMaxGroupsToMonitor:s}=await chrome.storage.sync.get("subscriptionMaxGroupsToMonitor");if(s)return s}catch(t){}return Re.MAX_GROUPS_TO_MONITOR.trial}(e);return{canEnable:t<s,currentCount:t,maxAllowed:s,remaining:s-t}}catch(t){return{canEnable:!1,currentCount:0,maxAllowed:Re.MAX_GROUPS_TO_MONITOR.trial,remaining:0,error:t.message}}}async function Me(){return U.timeAsync("scan","fullScan",async()=>{p=0,y=0;try{const{markNewPostsAsSeenOnNextScan:e}=await chrome.storage.sync.get("markNewPostsAsSeenOnNextScan");if(e){const e=(await Ee()).filter(e=>!e.isRead);if(e.length>0){e.length;for(const t of e)await ve(t.id)}await chrome.storage.sync.remove("markNewPostsAsSeenOnNextScan")}}catch(e){}if(!(await async function(){return !0}()))return _e({type:"scanComplete",results:[],processedCount:0,matchedCount:0,message:"Subscription required to scan groups. Please subscribe to continue."}),s=!1,void F("flag reset","access denied");void 0!==j&&await j.persistOnCriticalEvent("scanStart");try{re.invalidate("groups");const e=await pe(),t=e.filter(e=>!0===e.enabled);e.length,t.length;if(e.slice(0,5).forEach((e,t)=>{e.name,e.enabled,e.enabled}),0===t.length)return _e({type:"scanComplete",results:[],processedCount:0,matchedCount:0,message:"No groups enabled for scanning. Please enable groups in Settings > Facebook Groups."}),s=!1,void F("flag reset","no groups enabled");const{isDemoMode:r}=await chrome.storage.sync.get("isDemoMode");re.invalidate("keywords");const n=await ye();if(!n||0===n.length)return _e({type:"scanComplete",results:[],processedCount:0,matchedCount:0,message:"No keywords configured. Please add keywords in Settings > Keywords."}),s=!1,void F("flag reset","no keywords configured");const o=await we(),{facebookUserId:i}=await chrome.storage.sync.get("facebookUserId"),c=await Pe(i);let u=t;i&&t.length>c?(t.length,u=await De(t,i,c)):t.length<=c&&(u=Ae(t),t.length),u.length,t.length,n.length;const l=await new Promise(e=>{chrome.tabs.query({url:chrome.runtime.getURL("scan.html")},t=>{e(t)})});let h=null;if(0===l.length){const e=await function(e,t={}){return new Promise((s,r)=>{const n={url:e,type:"popup",width:450,height:300,focused:!1,left:100,top:100,...t};chrome.windows.create(n,e=>{chrome.runtime.lastError?r(new Error(chrome.runtime.lastError.message)):(e.id,a.add(e.id),s(e))})})}(chrome.runtime.getURL("scan.html"));setTimeout(()=>{chrome.tabs.query({windowId:e.id},e=>{e.length>0&&(h=e[0].id,Ne(h,u,n,o,r))})},2e3)}else h=l[0].id,l[0].windowId&&chrome.windows.update(l[0].windowId,{focused:!0}),Ne(h,u,n,o,r)}catch(e){throw _e({type:"scanError",error:e.message}),void 0!==j&&j.persistOnCriticalEvent("scanError").catch(e=>console.error("[FB Keyword Monitor] Error persisting state on scan error:",e)),s=!1,r=null,F("flag reset","iframe scan error"),e}})}function Ne(e,t,s,r,n=!1){const a={type:"COORDINATE_SCAN_ALL",enabledGroups:t,keywords:s,settings:r,isDemoMode:n};chrome.tabs.sendMessage(e,a).then(()=>{}).catch(e=>{_e(a)})}function _e(e){try{if(s&&["scanProgress","scanStatsUpdated"].includes(e.type)&&!e.isDemo)return void e.type;chrome.runtime.sendMessage(e).catch(()=>{}),chrome.tabs.query({url:chrome.runtime.getURL("*")},t=>{t.forEach(t=>{chrome.tabs.sendMessage(t.id,e).catch(()=>{})})});["COORDINATE_SCAN_ALL","scanWindowClosing"].includes(e.type)&&chrome.tabs.query({url:"*://*.facebook.com/*"},t=>{t.forEach(t=>{chrome.tabs.sendMessage(t.id,e).catch(()=>{})})})}catch(t){}}async function $e(e){try{const t=Date.now(),s=await se.getConfig(e,null);Date.now();return s}catch(t){const s=await me();return new Promise(t=>{const r=s.transaction(["config"],"readonly").objectStore("config").openCursor();r.onsuccess=s=>{const r=s.target.result;if(r){if(r.value.name===e)return void t(r.value.value);r.continue()}else t(null)},r.onerror=()=>{t(null)}})}}async function xe(e,t){se.cache.delete(e);const s=await me();return new Promise((r,n)=>{const a=s.transaction(["config"],"readwrite").objectStore("config"),o=a.openCursor();o.onsuccess=s=>{const o=s.target.result;if(o){if(o.value.name===e){const e=o.value;e.value=t;const s=o.update(e);return s.onsuccess=()=>{r()},void(s.onerror=e=>{e.target.error,n(e.target.error)})}o.continue()}else{const s=a.add({name:e,value:t});s.onsuccess=()=>{r()},s.onerror=e=>{e.target.error,n(e.target.error)}}},o.onerror=e=>{e.target.error,n(e.target.error)}})}chrome.windows.onRemoved.addListener(e=>{a.has(e)&&(a.delete(e),0===a.size&&s&&(s=!1,r=null,_e({type:"scanCancelled",reason:"User closed scan window",timestamp:Date.now()})))}),async function(){await de(),await async function(){return new Promise(e=>{chrome.storage.sync.get(["alertSettings"],t=>{t.alertSettings&&(w.ENABLE_NOTIFICATIONS=t.alertSettings.notifications??w.ENABLE_NOTIFICATIONS,w.ENABLE_BADGE=t.alertSettings.badge??w.ENABLE_BADGE),w.ENABLE_NOTIFICATIONS,w.ENABLE_NOTIFICATIONS&&async function(){try{chrome.notifications}catch(e){}}(),e()})})}(),await async function(){await he("startup")}(),await async function(){await ye();const e=await pe();e.length}()}();
